import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;

import java.util.List;
import java.util.Random;

/**
 * Represents a waypoint in the Minecraft world.
 * In a full mod, this might include a name, dimension, etc.
 */
class ModWaypoint {
    public BlockPos position;
    public String name;
    // Potentially: public String dimensionId;

    public ModWaypoint(BlockPos position, String name) {
        this.position = position;
        this.name = name;
    }

    @Override
    public String toString() {
        return name + " @ " + position.getX() + "," + position.getY() + "," + position.getZ();
    }
}

/**
 * Handles following a pre-calculated path of BlockPos for the player,
 * with human-like camera and movement.
 *
 * Assumes an A* algorithm (or similar) provides the path.
 */
public class PlayerPathFollower {

    private List<BlockPos> currentPath;
    private int currentPathIndex;
    private boolean active = false;
    private Random random = new Random();
    private MinecraftClient client;

    // Humanization parameters
    private float lookSpeedFactor = 0.15f; // How quickly to turn camera (lower is slower/smoother)
    private float minLookSpeedFactor = 0.05f; // Minimum speed to avoid getting stuck
    private double reachDistanceXZ = 0.4; // How close to get to a waypoint's XZ before advancing
    private double reachDistanceY = 1.0;  // How close for Y (allows for being on slabs/stairs near target Y)
    private int ticksSinceLastFidget = 0;
    private int nextFidgetTick = 100 + random.nextInt(200); // Ticks before a random small action

    // For smoothing/varying movement input
    private int forwardPressTicks = 0;
    private final int MAX_FORWARD_PRESS_TICKS_VARIATION = 5; // e.g. press W for 1 to 5 ticks then re-evaluate

    public PlayerPathFollower() {
        this.client = MinecraftClient.getInstance();
    }

    /**
     * Starts following the given path.
     * @param path A list of BlockPos representing the path, generated by an A* algorithm.
     */
    public void startPath(List<BlockPos> path) {
        if (path == null || path.isEmpty()) {
            System.out.println("PathFollower: Path is null or empty.");
            stop();
            return;
        }
        this.currentPath = path;
        this.currentPathIndex = 0;
        this.active = true;
        this.forwardPressTicks = 0; // Reset movement ticks
        System.out.println("PathFollower: Starting path with " + path.size() + " points.");
    }

    /**
     * Stops the current pathfinding operation.
     * Releases any pressed keys.
     */
    public void stop() {
        this.active = false;
        this.currentPath = null;
        this.currentPathIndex = 0;
        releaseAllKeys();
        System.out.println("PathFollower: Stopped.");
    }

    public boolean isActive() {
        return active;
    }

    private void releaseAllKeys() {
        if (client.options == null) return;
        client.options.forwardKey.setPressed(false);
        client.options.backKey.setPressed(false);
        client.options.leftKey.setPressed(false);
        client.options.rightKey.setPressed(false);
        client.options.jumpKey.setPressed(false);
        client.options.sprintKey.setPressed(false);
    }

    /**
     * This method should be called every client tick.
     */
    public void onClientTick() {
        if (!active || client.player == null || client.world == null || currentPath == null || currentPath.isEmpty()) {
            if (active) stop(); // Ensure cleanup if something went wrong
            return;
        }

        ClientPlayerEntity player = client.player;

        if (currentPathIndex >= currentPath.size()) {
            System.out.println("PathFollower: Reached end of path.");
            stop();
            return;
        }

        BlockPos currentTargetBlock = currentPath.get(currentPathIndex);
        Vec3d playerPos = player.getPos();
        // Target the center of the block, slightly above its base for looking
        Vec3d targetPosVec = new Vec3d(
            currentTargetBlock.getX() + 0.5,
            currentTargetBlock.getY() + 0.5, // Look towards mid-block or player eye level if block is at feet
            currentTargetBlock.getZ() + 0.5
        );

        // --- 1. Camera Control (Smooth Turning & Human-like Sway) ---
        lookAt(player, targetPosVec);

        // --- 2. Movement Decisions ---
        double distXZ = playerPos.horizontalDistanceTo(new Vec3d(targetPosVec.x, playerPos.y, targetPosVec.z));
        double distY = Math.abs(playerPos.y - (currentTargetBlock.getY())); // Distance to block's base Y

        // Check if waypoint is reached
        // More lenient Y check, as player might be on a slab or stair at the target XZ
        if (distXZ < reachDistanceXZ && distY < reachDistanceY) {
            currentPathIndex++;
            forwardPressTicks = 0; // Reset for next segment
            if (currentPathIndex >= currentPath.size()) {
                System.out.println("PathFollower: Reached final waypoint.");
                stop();
                return;
            }
            // Update target for next iteration, helps avoid stale target if processing takes time
            currentTargetBlock = currentPath.get(currentPathIndex);
            targetPosVec = new Vec3d(
                currentTargetBlock.getX() + 0.5,
                currentTargetBlock.getY() + 0.5,
                currentTargetBlock.getZ() + 0.5
            );
            System.out.println("PathFollower: Advanced to waypoint " + currentPathIndex + ": " + currentTargetBlock);
        }

        // Only move if generally facing the target
        float yawDifference = Math.abs(MathHelper.wrapDegrees(getYawToTarget(player, targetPosVec) - player.getYaw()));
        
        // Reset keys at the start of logic for this tick, then set them if needed
        client.options.forwardKey.setPressed(false);
        client.options.jumpKey.setPressed(false);
        client.options.sprintKey.setPressed(false); // Manage sprint carefully

        if (yawDifference < 30.0f) { // If looking somewhat towards the target
            if (forwardPressTicks <= 0) {
                // Decide how long to press W, adds a bit of human-like hesitation/burst
                forwardPressTicks = 1 + random.nextInt(MAX_FORWARD_PRESS_TICKS_VARIATION);
            }
            client.options.forwardKey.setPressed(true);
            forwardPressTicks--;

            // Sprinting logic (simple version)
            if (distXZ > 2.0 && player.getHungerManager().getFoodLevel() > 6) { // Don't sprint if close or starving
                 if(random.nextInt(100) < 60) { // Chance to sprint
                    client.options.sprintKey.setPressed(true);
                 }
            }

            // Jumping logic
            // This needs to be more sophisticated, ideally path nodes from A* would indicate a jump
            BlockPos blockInFront = BlockPos.ofFloored(playerPos.add(player.getRotationVecClient().multiply(0.5, 0, 0.5))); // Simplified
            BlockPos blockAboveInFront = blockInFront.up();
            BlockPos targetBlockFloor = currentTargetBlock.down(); // Block player would stand on for target

            // If target is one block higher and directly ahead, and we are on ground
            if (currentTargetBlock.getY() > player.getBlockY() &&
                currentTargetBlock.getY() <= player.getBlockY() + 1.2 && // Target is roughly 1 block higher
                distXZ < 1.5 && // And we are close horizontally
                player.isOnGround()) {
                
                // Check if the space above the block in front is clear, and target is reachable by jump
                // This is a very simplified check. A* should ideally mark jump nodes.
                if (client.world.getBlockState(blockInFront).isSolid() && 
                    !client.world.getBlockState(blockAboveInFront).isSolid() &&
                    !client.world.getBlockState(blockAboveInFront.up()).isSolid() && // space for head
                    (currentTargetBlock.getX() == blockAboveInFront.getX() && currentTargetBlock.getZ() == blockAboveInFront.getZ() ||
                     currentTargetBlock.getX() == player.getBlockX() && currentTargetBlock.getZ() == player.getBlockZ() ) // target is the jump-to block or current
                    ) {
                     client.options.jumpKey.setPressed(true);
                }
            }

        } else {
            // Not facing target, stop moving forward to allow turning
            client.options.forwardKey.setPressed(false);
            client.options.sprintKey.setPressed(false);
            forwardPressTicks = 0; // Reset if we stopped moving to turn
        }

        // --- 3. Human-like Fidgets (subtle) ---
        ticksSinceLastFidget++;
        if (ticksSinceLastFidget >= nextFidgetTick) {
            performFidget(player);
            ticksSinceLastFidget = 0;
            nextFidgetTick = 200 + random.nextInt(400); // Reset timer (10-30 seconds)
        }
    }

    private float getYawToTarget(ClientPlayerEntity player, Vec3d targetPos) {
        double deltaX = targetPos.x - player.getX();
        double deltaZ = targetPos.z - player.getZ();
        return (float) (MathHelper.atan2(deltaZ, deltaX) * (180.0 / Math.PI)) - 90.0f;
    }

    private float getPitchToTarget(ClientPlayerEntity player, Vec3d targetPos) {
        double deltaX = targetPos.x - player.getX();
        double deltaY = targetPos.y - (player.getY() + player.getEyeHeight(player.getPose()));
        double deltaZ = targetPos.z - player.getZ();
        double horizontalDistance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);
        return (float) -(MathHelper.atan2(deltaY, horizontalDistance) * (180.0 / Math.PI));
    }

    private void lookAt(ClientPlayerEntity player, Vec3d targetPos) {
        float targetYaw = getYawToTarget(player, targetPos);
        float targetPitch = getPitchToTarget(player, targetPos);

        // Add slight random sway to the target look angles for humanization
        targetYaw += (random.nextFloat() - 0.5f) * 1.5f; // +/- 0.75 degree sway
        targetPitch += (random.nextFloat() - 0.5f) * 1.0f; // +/- 0.5 degree sway
        targetPitch = MathHelper.clamp(targetPitch, -90.0f, 90.0f); // Clamp pitch

        float currentYaw = player.getYaw();
        float currentPitch = player.getPitch();

        // Smooth interpolation
        // Adjust speed factor dynamically: faster if far off, slower if close to target angle
        float yawDiff = MathHelper.wrapDegrees(targetYaw - currentYaw);
        float pitchDiff = targetPitch - currentPitch; // Pitch doesn't wrap the same way

        float effectiveLookSpeed = Math.max(minLookSpeedFactor, lookSpeedFactor * (Math.abs(yawDiff) / 45.0f)); // Faster turn if further away

        player.setYaw(currentYaw + MathHelper.clamp(yawDiff, -effectiveLookSpeed * 45, effectiveLookSpeed * 45) * effectiveLookSpeed);
        player.setPitch(currentPitch + MathHelper.clamp(pitchDiff, -effectiveLookSpeed * 30, effectiveLookSpeed*30) * effectiveLookSpeed * 0.7f); // Pitch changes a bit slower
    }

    private void performFidget(ClientPlayerEntity player) {
        int fidgetType = random.nextInt(3);
        switch (fidgetType) {
            case 0: // Tiny head look
                float originalYaw = player.getYaw();
                float originalPitch = player.getPitch();
                player.setYaw(originalYaw + (random.nextFloat() - 0.5f) * 10f); // Look +/- 5 deg
                player.setPitch(originalPitch + (random.nextFloat() - 0.5f) * 5f);
                // In a real scenario, you might want to smoothly return to original look or next target
                System.out.println("PathFollower: Fidget - tiny head look.");
                break;
            case 1: // Brief pause in movement (if moving)
                if (client.options.forwardKey.isPressed()) {
                    client.options.forwardKey.setPressed(false); // Will be re-evaluated next tick
                    forwardPressTicks = -5; // Force a small pause by setting ticks to a "just finished" state
                    System.out.println("PathFollower: Fidget - brief pause.");
                }
                break;
            case 2: // Quick strafe tap (if not already strafing)
                if (!client.options.leftKey.isPressed() && !client.options.rightKey.isPressed()) {
                    KeyBinding strafeKey = random.nextBoolean() ? client.options.leftKey : client.options.rightKey;
                    strafeKey.setPressed(true);
                    // Need a mechanism to release it after 1-2 ticks, or rely on next tick's logic to clear it
                    // For simplicity, we'll let the main logic clear it if not continuously needed.
                    System.out.println("PathFollower: Fidget - quick strafe tap.");
                }
                break;
        }
    }
}